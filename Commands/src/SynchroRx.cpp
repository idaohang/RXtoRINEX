/** @file SynchroRX.cpp
 * Contains the command line program to synchronize receiver and computer to allow reception of GPS receiver data.
 * The current implementation of is program synchronizes Windows comm ports and SiRF IV receiver.
 *<p>Usage:
 *<p>SynchroRX.exe {options}
 *<p>Options are:
 *	- -h or --help : Show usage data. Default value HELP=FALSE
 *	- -l LOGLEVEL or --llevel=LOGLEVEL : Maximum level to log (SEVERE, WARNING, INFO, CONFIG, FINE, FINER, FINEST). Default value LOGLEVEL = INFO
 *	- -p COMPORT or --port=COMPORT : Serial port name where receiver is connected. Default value COMPORT = COM35
 *	- -m MODE or --mode=MODE : Set receiver protocol to NMEA or OSP. Default value MODE = NMEA
 *<p>
 *Copyright 2015 Francisco Cancillo
 *<p>
 *This file is part of the RXtoRINEX tool.
 *<p>
 *RXtoRINEX is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License
 *as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 *RXtoRINEX is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 *warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *See the GNU General Public License for more details.
 *A copy of the GNU General Public License can be found at <http://www.gnu.org/licenses/>.
 *
 *V1.0	First release
 */

//from CommonClasses
#include "ArgParser.h"
#include "Logger.h"
#include "Utilities.h"
//from SerialTxRx
#include "SerialTxRx.h"

#include <stdio.h>

using namespace std;

///The command line format
const string CMDLINE = "SynchroRX.exe {options}";
///Default baud rate for OSP binary data transfers
#define OSPbRate 57600
///Default baud rate for NMEA ASCII data transfers
#define NMEAbRate 9600
//@cond DUMMY
///The parser object to store options and operators passed in the comman line
ArgParser parser;
//Metavariables for options
int HELP, LOGLEVEL, COMPORT, MODE; //metavariables for options in the command line call
//Metavariables for operators

//Protocols / modes used by the receiver to exchange data
enum protocol {OSP=0, NMEA, UNKNOWN};
//Bit rates that can be used 
const int bRates[] = {NMEAbRate, OSPbRate, 1200, 2400, 4800, 38400, 115200, 0};
//arguments for receiver commands
//NMEA cmd args to change mode from NMEA to OSP at 57600 bps baud rate 
char* cmdNMEA100 = "0,57600,8,1,0";
//OSP cmd args to set baud rate at 57600 bps
char* cmdOSP134 = "00 00 E1 00 08 01 00 00";
//OSP cmd args to change mode from OSP to NMEA at 9600 bps baud rate 
char* cmdOSP129 = "02 01 01 00 01 01 01 05 01 01 01 00 01 00 01 00 01 00 01 00 01 25 80";

//functions in this module
bool checkProtocol(protocol prtcl, SerialTxRx port, int ntimes, Logger* plog);
string protocolTXT (protocol p);
//@endcond 

/**main
 * gets the command line arguments, set parameters accordingly, and checks and sets
 * the serial comm port and the receiver as requested.
 *
 *The receiver state is defined by the following:
 *	- The serial port bit rate, stop bits, and parity being used
 *	- The protocol mode being used by receiver to send data: NMEA or OSP
 *	- If data is flowing from the receiver or not.
 *
 *The computer data acquisition process state is defined by:
 *	- The port (port name) used for the communication with the GPS receiver
 *	- The serial port bit rate, stop bits, and parity being used
 *	- The type of data required: NMEA or OSP
 *
 * To allow communication between GPS receiver and computer, states of both elements shall be synchronized
 * according to the needs stated. To synchronize the computer port and the receiver their current states shall
 * be known. But, to know the receiver state is necessary to communicate with it, setting the computer port at 
 * the same speed, stop bits and parity that the receiver. This will allow receiving and analyzing the data being
 * generated by the receiver to know the protocol it is using. As receiver state may be not known initially, it
 * would be necessary to scan at different speeds data being received to identify the protocol. 
 *<p>
 *To allow synchronization it is assumed the following for the receiver:
 * - It is providing data continuously, ASCII NMEA or binary OSP messages, depending on the mode.
 * - It is receiving/sending data at 1200, 2400, 4800, 9600, 38400, 57600 or 115200 bps, with one stop bit and parity none.
 *<p>
 * After synchronization, bit rates will be set to 9600 bps when exchanging NMEA data
 * or to 57600 bps when exchanging OSP messages..
 *
 * @param argc	the number of arguments passed from the command line
 * @param argv	array with argument values passed
 * @return the exit status according to the following values and meaning:
 *	- (0) Receiver protocol mode changed to requested value (OSP or NMEA). Baud rate set accordingly.
 *	- (1) Error in the command line arguments passed to the program
 *	- (2) An error occurred when setting computer port parameters, or when sending or reciving data. See log file for details.
 *	- (3) Unable to change to the protocol mode requested. See log file for details.
 */
int main(int argc, char** argv) {
	string logMsg;	//multipurse string
	/**The main process sequence follows:*/
	/// 1- Defines and sets the error logger object
	Logger log("LogFile.txt");
	log.setPrgName(argv[0]);
	/// 2- Setups the valid options in the command line. They will be used by the argument/option parser
	MODE = parser.addOption("-m", "--mode", "MODE", "Set receiver protocol to NMEA or OSP", "NMEA");
	COMPORT = parser.addOption("-p", "--port", "COMPORT", "Serial port name where receiver is connected", "COM35");
	LOGLEVEL = parser.addOption("-l", "--llevel", "LOGLEVEL", "Maximum level to log (SEVERE, WARNING, INFO, CONFIG, FINE, FINER, FINEST)", "INFO");
	HELP = parser.addOption("-h", "--help", "HELP", "Show usage data", false);
	/// 4- Parses arguments in the command line extracting options and operators
	try {
		parser.parseArgs(argc, argv);
	}  catch (string error) {
		parser.usage("Argument error: " + error, CMDLINE);
		log.severe(error);
		return 1;
	}
	log.info("Start execution with " + parser.showOptValues());
	if (parser.getBoolOpt(HELP)) {
		parser.usage("checks and/or sets the communications port and the SiRF IV receiver state", CMDLINE);
		return 0;
	}
	/// 5- Sets logging level stated in option
	logMsg = parser.getStrOpt (LOGLEVEL);
	if (logMsg.compare("SEVERE") == 0) log.setLevel(SEVERE);
	else if (logMsg.compare("WARNING") == 0) log.setLevel(WARNING);
	else if (logMsg.compare("INFO") == 0) log.setLevel(INFO);
	else if (logMsg.compare("CONFIG") == 0) log.setLevel(CONFIG);
	else if (logMsg.compare("FINE") == 0) log.setLevel(FINE);
	else if (logMsg.compare("FINER") == 0) log.setLevel(FINER);
	else if (logMsg.compare("FINEST") == 0) log.setLevel(FINEST);
	/// 6- Gets from option the protocol mode to be used.
	protocol wantedMode = NMEA;		//default value
	if(parser.getStrOpt(MODE) == "OSP") wantedMode = OSP;
	int wantedBaud = wantedMode==OSP? OSPbRate : NMEAbRate;
	DBGRPT("From options:wantedMode=%d;wantedBaud=%d\n", wantedMode, wantedBaud);
	/// 7 - Opens computer serial port and gets and logs its current state
	SerialTxRx port;
	int currentSize = -1;
	bool currentParity;
	int currentBaud;
	char textBuf[200];
	protocol currentMode = UNKNOWN;
	try {
		/// 8 - Discovers receiver current mode and baud rate. First look for "most likely" ones taking in to account
		///		current baud rate of computer comm port (would be NMEAbRate or OSPbRate):
		///	- When is NMEAbRate, checks if receiver mode is NMEA. If it is not, sets port at OSPbRate and checks
		///		if mode is OSP.
		///	- When is OSPbRate, checks if receiver mode is OSP. If is is not, sets port at NMEAbRate and checks
		///		if mode is NMEA. 
		port.openPort(parser.getStrOpt(COMPORT));
		port.getPortParams(currentBaud, currentSize, currentParity);
		sprintf(textBuf, "Port initial settings: BaudRate=%d; ByteSize=%d; Parity=%c", currentBaud, currentSize, currentParity?'T':'F');
		DBGRPT("%s\n", textBuf)
		log.info(string(textBuf));
		if (currentBaud!=NMEAbRate && currentBaud!=OSPbRate) {
			DBGRPT("Set BaudRate=%d\n", NMEAbRate)
			port.setPortParams(NMEAbRate);
			currentBaud = NMEAbRate;
		}
		if (currentBaud == NMEAbRate) {
			if(checkProtocol(NMEA, port, 2, &log)) currentMode = NMEA;
			else {
				DBGRPT("Set OSP BaudRate=%d\n", OSPbRate)
				port.setPortParams(OSPbRate);
				if(checkProtocol(OSP, port, 2, &log)) currentMode = OSP;
			}
		} else if (currentBaud == OSPbRate) {
			if(checkProtocol(OSP, port, 2, &log)) currentMode = OSP;
			else {
				DBGRPT("Set NMEA BaudRate=%d\n", NMEAbRate)
				port.setPortParams(NMEAbRate);
				if(checkProtocol(NMEA, port, 2, &log)) currentMode = NMEA;
			}
		}
		log.info("Initial receiver protocol is " + protocolTXT(currentMode));
		DBGRPT("Initial currentMode= %d\n", currentMode)
		/// 9- When failed to discover receiver mode at usual baud rates, iterate over all baud rates
		///		setting computer port speed and sending NMEA and OSP commands to set its mode to OSP at 57600 bps.
		///		Then checks if the current receiver mode has changed to OSP.
		if (currentMode == UNKNOWN) {	//mode not identified at usual baud rates
			//broadcast a change to OSP at 57600 in the receiver using all baud rates in the computer
			DBGRPT("Synchronizing..\n")
			for(int i=0; bRates[i]!=0; i++) {
				DBGRPT("Send at %d bps cmdNMEA100\n", bRates[i])
				port.setPortParams(bRates[i]);
				port.writeNMEAcmd(100,cmdNMEA100); port.writeNMEAcmd(100,cmdNMEA100);
			}
			for(int i=0; bRates[i]!=0; i++) {
				DBGRPT("Send at %d bps cmdOSP129\n", bRates[i])
				port.setPortParams(bRates[i]);
				port.writeOSPcmd(134,cmdOSP134);
				port.writeOSPcmd(134,cmdOSP134);
			}
			port.setPortParams(OSPbRate);
			if(checkProtocol(OSP, port, 2, &log)) currentMode = OSP;
			log.info("After broadcasting change to OSP: protocol is " + protocolTXT(currentMode));
			DBGRPT("Resulting currentMode=%d\n", currentMode)
		}
		/// 10- If the current receiver mode is OSP, but it is wanted to be NMEA, sends a OSP command
		///		to change it, and sets computer com speed at NMEAbRate. Then checks if new mode has changed to NMEA.
		if (currentMode==OSP && wantedMode==NMEA) {
			DBGRPT("In OSP, sends cmdOSP129->change to NMEA 9600\n")
			port.writeOSPcmd(129,cmdOSP129);
			port.setPortParams(NMEAbRate);
			if(checkProtocol(NMEA, port, 10, &log)) currentMode = NMEA;
		/// 11- If the current receiver mode is NMEA, but it is wanted to be OSP, sends a NMEA command
		///		to change it, and sets computer com speed at OSPbRate Then checks if new mode has changed to OSP.
		} else if (currentMode==NMEA && wantedMode==OSP) {
			DBGRPT("In NMEA, sends cmdNMEA100->change to OSP 57600\n")
			port.writeNMEAcmd(100,cmdNMEA100);
			port.setPortParams(OSPbRate);
			if(checkProtocol(OSP, port, 10, &log)) currentMode = OSP;
		}
		sprintf(textBuf, "Final receiver protocol=%s; change is %s", protocolTXT(currentMode).c_str(), currentMode==wantedMode? "OK" : "NOK");
		log.info(string(textBuf));
		DBGRPT("%s\n", textBuf)
		port.getPortParams(currentBaud, currentSize, currentParity);
		sprintf(textBuf, "Port final settings: BaudRate=%d; ByteSize=%d; Parity=%c\n", currentBaud, currentSize, currentParity?'T':'F');
		log.info(string(textBuf));
		DBGRPT("%s\n", textBuf)
	} catch (string error) {
		log.severe(error);
		return 2;
	}
	/// 12- Verify if the resulting current mode is the wanted one, and returns value accordingly
	if (currentMode!=wantedMode) return 3;
	return 0;
}

//@cond DUMMY
/**checkProtocol
 * checks if the given protocol is currently being used by the GPS receiver.
 *
 * @param prtcl the protocol to be checked (OSP or NMEA)
 * @param port the computer SerialTxRx object being used for communications with the GNSS receiver
 * @param ntimes the maximum number of messages to be checked before returning a false result 
 * @param plog the pointer to the logger
 * @return true when a correct message of the given protocol is received, false otherwise
 */
bool checkProtocol(protocol prtcl, SerialTxRx port, int ntimes, Logger* plog) {
	int resultCode;
	char textBuf[100];
	sprintf(textBuf, "%s", prtcl==NMEA?"Checks NMEA" : "Checks OSP");
	DBGRPT("%s:\n", textBuf)
	do {
		resultCode = prtcl==NMEA? port.readNMEAmsg(500) : port.readOSPmsg(500);
#if defined (_DEBUG)
		DBGRPT("%s=%d:msg(%d)", textBuf, resultCode, port.payloadLen)
		if (port.payloadLen > 0) {
			if (prtcl==NMEA) DBGRPT("=%s", port.payBuff)
			else DBGRPT("mid=%u", (unsigned int) port.payBuff[0])
		}
		DBGRPT("\n")
#endif
		ntimes--;
	} while (resultCode!=0 && ntimes>0);
	plog->fine(string(textBuf) + " Result=" + to_string((_Longlong) resultCode));
	return resultCode == 0;
}

/**protocolTXT
 * gives a readable description on the protocol
 */
string protocolTXT (protocol p) {
	switch (p) {
	case NMEA: return "NMEA";
	case OSP: return "OSP";
	default: return "UNKNOWN";
	}
}
//@endcond 
